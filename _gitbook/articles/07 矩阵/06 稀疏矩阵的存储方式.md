# 稀疏矩阵的存储方式

## 三元组存储

和特殊矩阵不同的是，稀疏矩阵中的非零元素并没有特殊的分布规律，所以不便利用下标变换公式将其映射到一维数组中。在实际应用中，需要处理的稀疏矩阵常常较大，例如一个 100\*100 的矩阵只有 50 个非零元素，若存储矩阵中所有的元素（10000 个）会浪费大量的存储空间，所以**只考虑存储其中的非零元素**，就是实现了稀疏矩阵的**压缩存储**。

由于非零元素的分布无规律，可以用一个**包含行下标、列下标和矩阵元素值的三元组**，唯一地确定一个矩阵元素，再由所有非零元素的三元组构成一个线性表（称之为**三元组表**）来表示一个稀疏矩阵，示意图如下：

![](.\images\稀疏矩阵.png)

稀疏矩阵的三元组表一般**以行优先、顺序存储元素**，其一般数据结构定义如下：

```c
// 非零元素个数的最大值
#define SIZE 100

// 三元组
typedef struct {
    // 元素的值，此处为 int 类型，也可以自定义类型
    int e;
    // 元素所处行、元素所处列
    int row, col;
} Triple;

// 稀疏矩阵
typedef struct {
    // 三元组表，从 1 下标开始存储元素，0 下标不使用
    Triple array[SIZE+1];
    // 矩阵的行数、矩阵的列数、非零元素的个数
    int row_num, col_num, e_num;
} Matrix;
```

其一般算法实现如下：

```c
// 创建稀疏矩阵的三元组表示
Status CreateMatrix(Matrix &m) {
    // 0 下标不使用
    m.array[0].row = m.array[0].col = 0;
    
    // 接收矩阵的规模
    printf("请输入矩阵的行数、列数、非零元素，格式为【%%d,%%d,%%d】：\n");
    scanf("%d,%d,%d", &m.row_num, &m.col_num, &m.e_num);
    
    // 定义三元组临时变量
    Triple temp;
    // 存储矩阵元素
    for (int i = 1; i <= m.e_num; i++) {
        // 用死循环来校验输入的有效性，输入正确时结束循环
        while (1) {
            printf("请按行序顺序输入第%d个非零元素所在的行、列、元素值，格式为【%%d,%%d,%%d】：\n", i);
            scanf("%d,%d,%d", &temp.row, &temp.col, &temp.e);
            // 校验元素的行列是否超出边界
            if (temp.row < 1 || temp.col < 1 || temp.row > m.row_num || temp.col > m.col_num) {
                continue;
            }
            // 校验元素的行列是否小于上一个元素
            if (temp.row < m.array[i - 1].row || (temp.row == m.array[i - 1].row && temp.col <= m.array[i-1].col)) {
                continue;
            }
            // 存储元素
            m.array[i] = temp;
            break;
        }
    }
    return OK;
}

// 打印稀疏矩阵
void PrintMatrix(Matrix m) {
    printf("行\t列\t值\n");
    for (int i = 1; i<= m.e_num; i++) {
        printf("%d\t%d\t%d\n", m.array[i].row, m.array[i].col, m.array[i].e);
    }
}

// 矩阵和，将两矩阵中的元素揉合成一个新矩阵，相同位置的元素值相加
Status AddMatrix(Matrix m1, Matrix m2, Matrix &_new) {
	// 如果两矩阵的行与列的数量不相等
	if (m1.row_num != m2.row_num || m1.col_num != m2.col_num) {
		return ERROR;
	}

	// 初始化新矩阵
	_new.row_num = m1.row_num;
	_new.col_num = m1.col_num;
	_new.e_num = 0;

	// 存储新矩阵的元素，i 是 _new 的下标，j 是 m1 的下标，k 是 m2 的下标
	int i = 1, j = 1, k = 1;
    // 按照行列从小到大的顺序存储
    // 若是两元素行列相同，则将其值相加
    // 每次循环只存储一个对应行列的元素，防止同时存储两个不同行列的元素后，导致大小排序混乱以及错过行列相同的两元素
	while (j <= m1.e_num && k <= m2.e_num) {
		// 首先考虑两元素所处行不相等的情况
		if (m1.array[j].row != m2.array[k].row) {
			// 将行小的元素添加到 _new 中
			if (m1.array[j].row < m2.array[k].row) {
				_new.array[i++] = m1.array[j++];
			} else {
				_new.array[i++] = m2.array[k++];
			}
		} else {
			// 如果所处列也相等，就将两元素值相加
			if (m1.array[j].col == m2.array[k].col) {
                // 若元素和为零，则不存储
                if (m1.array[j].e + m2.array[k].e == 0) {
                    continue;
                }
                _new.array[i] = m1.array[j++];
                _new.array[i++].e += m2.array[k++].e;
			} else {
				// 将列小的元素添加到 _new 中
				if (m1.array[j].col < m2.array[k].col) {
					_new.array[i++] = m1.array[j++];
				} else {
					_new.array[i++] = m2.array[k++];
				}
			}
		}
		// 更新 _new 内存储的元素数量
		_new.e_num++; 
	}
    
	// 存储遗漏的元素
    // 剩下的元素的行列肯定比现有的元素大，所以直接存储即可，不需要考虑大小排序
	while (j <= m1.e_num) {
		_new.array[i++] = m1.array[j++];
		_new.e_num++; 
	}
	while (k <= m2.e_num) {
		_new.array[i++] = m2.array[k++];
		_new.e_num++; 
	}
	return OK;
}

// 矩阵差，m1 - m2 
Status SubMatrix(Matrix m1, Matrix m2, Matrix &_new) {
	// 如果两矩阵的行与列的数量不相等
	if (m1.row_num != m2.row_num || m1.col_num != m2.col_num) {
		return ERROR;
	}
    
    // 先将 m2 的所有元素值取相反数（若规定为 m2 - m1，则将 m1 的元素取反） 
    for (int i = 1; i<= m2.e_num; i++) {
        m2.array[i].e *= -1;
    }
    // 再调用矩阵和算法即可完成矩阵差算法
    AddMatrix(m1, m2, _new);
    return OK;
}

// 矩阵积
Status MultMatrix(Matrix m1, Matrix m2, Matrix &_new) {
	// 如果两矩阵的行与列的数量不相等
	if (m1.row_num != m2.row_num || m1.col_num != m2.col_num) {
		return ERROR;
	}

	// 初始化新矩阵
	_new.row_num = m1.row_num;
	_new.col_num = m1.col_num;
	_new.e_num = 0;

	// 存储新矩阵的元素，i 是 _new 的下标，j 是 m1 的下标，k 是 m2 的下标
	int i = 1, j = 1, k = 1;
    // 按照行列从小到大的顺序存储
    // 若是两元素行列相同，则将其值相乘
    // 每次循环只存储一个对应行列的元素（值为 0），防止同时存储两个不同行列的元素后，导致大小排序混乱以及错过行列相同的两元素
	while (j <= m1.e_num && k <= m2.e_num) {
		// 首先考虑两元素所处行不相等的情况
		if (m1.array[j].row != m2.array[k].row) {
			// 将行小的元素添加到 _new 中
			if (m1.array[j].row < m2.array[k].row) {
				_new.array[i] = m1.array[j++];
				_new.array[i++].e = 0;
			} else {
				_new.array[i] = m2.array[k++];
				_new.array[i++].e = 0;
			}
		} else {
			// 如果所处列也相等，就将两元素值相加
			if (m1.array[j].col == m2.array[k].col) {
				_new.array[i] = m1.array[j++];
				_new.array[i++].e *= m2.array[k++].e;
			} else {
				// 将列小的元素添加到 _new 中
				if (m1.array[j].col < m2.array[k].col) {
					_new.array[i] = m1.array[j++];
					_new.array[i++].e = 0;
				} else {
					_new.array[i] = m2.array[k++];
					_new.array[i++].e = 0;
				}
			}
		}
		// 更新 _new 内存储的元素数量
		_new.e_num++;
	}

	// 存储遗漏的元素
	// 剩下的元素的行列肯定比现有的元素大，所以直接存储即可，不需要考虑大小排序
	while (j <= m1.e_num) {
		_new.array[i] = m1.array[j++];
		_new.array[i++].e = 0;
		_new.e_num++;
	}
	while (k <= m2.e_num) {
		_new.array[i] = m2.array[k++];
		_new.array[i++].e = 0;
		_new.e_num++;
	}
	return OK;
}
```

## 十字链表存储

用顺序存储结构存储稀疏矩阵的三元组线性表结构易于理解，可以节省很多存储单元，但缺点是顺序表的长度不易设定，可能存在溢出与浪费的问题，例如：

- 当非零元素增加或减少时，若矩阵元素的值由零元素变成非零元素，就要向顺序表中插入一个三元组；若非零元素变成非零元素，就要从顺序表中删除一个三元组。
- 为了保持顺序表数据元素之间的相对顺序，进行插入和删除操作时，就必须移动数据元素，操作很不方便。

以链式存储结构存储稀疏矩阵的三元组线性表可以克服这些不足，称之为**十字链表**。

在三元组十字链表表示中，**每个结点有五个域**，除了行号、列号和值这三个域外，另设两个指针域 right 和 down：

- **right 域** - 指向同一行的下一个非零元素的指针。
- **down 域** - 指向同一列的下一个非零元素的指针。

通过 right 指针把同一行的所有三元组链接成一个单链表，通过 down 指针把同一列的所有三元组连接成一个单链表，这样稀疏矩阵就形成了一个十字交叉的效果，故称其为稀疏矩阵三元组的十字链表存储结构，示意图如下：

![](.\images\稀疏矩阵的十字链表.png)