# 稀疏矩阵的转置

## 普通转置

稀疏矩阵操作的讨论重点是**转置操作**。

要实现稀疏矩阵的转置操作，需要比较 A 和 B 两互为**转置矩阵**的稀疏矩阵。若两个矩阵在行列互换后与对方相等，则称它们互为转置矩阵，示意图如下：

![](.\images\转置矩阵.png)

若矩阵 $$A$$ 是 $$m{\times}n$$ 的规模，则它的转置矩阵 $$B$$ 就是 $$n{\times}m$$ 的规模，且有：


$$
A(row,col)=B(col,row)\ (1\leq{row}\leq{n},1\leq{col}\leq{m})
$$


假设 $$a$$ 和 $$b$$ 是 Matrix 类型的变量，分别表示矩阵 $$A$$ 和 $$B$$。若要由 $$a$$ 转化得到 $$b$$，需要进行以下三个方面的变换：

1. 将矩阵的行列值互换。
2. 将每个三元组中的 row 和 col 值互换。
3. 调整三元组之间的顺序，按 $$B$$ 的行为主序依次排列。

有两种方法可以实现 $$a$$ 到 $$b$$ 的转换。最简单的方法是把 $$a$$ 三元组中的 row 和 col 互换，然后再对新的三元组行号按从小到大排列，就可以得到 $$b$$ 的三元组，时间复杂度为 **$$O(e{\_}num^2)$$**，一般算法实现如下：

```c
Status TransposeMatrix(Matrix a, Matrix &b) {
    // 没有非零元素时终止执行
    if (!a.e_num) {
        return ERROR;
    }
    // 将 a 转置给 b
    b.row_num = a.row_num;
    b.col_num = a.col_num;
    b.e_num = a.e_num;
    for (int i = 1; i <= a.e_num; i++) {
        b.array[i].row = a.array[i].col;
        b.array[i].col = a.array[i].row;
        b.array[i].e = a.array[i].e;
    }
    // 为 b 按照行列顺序从小到大排列
    Triple temp;
    for (int i = 1; i <= b.e_num - 1; i++) {
        for (int j = 1; j <= b.e_num - i; j++) {
        	// 因为在 a 里面已经是按照行序顺序排列了，在 b 里行转换成列后，只需要顺序排列行
            if (b.array[j].row > b.array[j + 1].row) {
                temp = b.array[j];
                b.array[j] = b.array[j + 1];
                b.array[j + 1] = temp;
            }
        }
    }
    return OK;
}
```

这种简单的方法需要一遍又一遍扫描矩阵，而另一种方法不需要在 row 和 col 互换后对新的三元组重新排列，改而把 row 和 col 交换后直接放在正确的位置上，提高转置效率，这就是稀疏矩阵的**快速转置算法**。

## 快速转置

快速转置算法的关键是要**确定矩阵 $$A$$ 中每一列（等于 $$B$$ 中每一行）第一个非零元素在 $$b$$ 中的关键位置**，与这些非零元素同列的三元组就依次放在它们后面。为了记录这些信息，需要引入两个辅助数组 num 和 first：

- **num 数组** - 用来存放事先统计的稀疏矩阵 $$A$$ 各列的非零元素个数，也就是转置矩阵 $$B$$ 各行的非零元素个数。
- **first 数组** - 用来存放事先计算出来的稀疏矩阵各行三元组第一个元素在转置矩阵 $$B$$ 中应存放的起始位置。

快速转置的一般算法实现如下：

```c
Status FastTransposeMatrix(Matrix a, Matrix &b) {
    // 没有非零元素时终止执行
    if (!a.e_num) {
        return ERROR;
    }
    
    // 辅助数组，同样的，0 下标不存放值，从 1 下标开始
    int num[a.col_num + 1], first[a.col_num + 1];
    // 初始化 num 
    for (int i = 0; i < a.col_num + 1; i++) {
    	num[i] = 0;
	}
    // 求 a 中每一列含非零元素的个数
    for (int i = 1; i <= a.e_num; i++) {
        num[a.array[i].col]++;
    }
    // 求第 col 列中第一个非零元素在 b 中的序号
    first[1] = 1;
    for (int i = 2; i <= a.col_num; i++) {
        first[i] = first[i - 1] + num[i - 1];
    }
    
    // 转置
    b.row_num = a.row_num;
    b.col_num = a.col_num;
    b.e_num = a.e_num;
    for (int i = 1; i <= a.e_num; i++) {
    	// 通过辅助数组获取当前元素应当存储在 b 的何处（下标）
        // 同时因为同行可能有多个非零元素，所以要使其值加一，让后续的元素被正确地存储
        int b_idx = first[a.array[i].col]++;
        b.array[b_idx].row = a.array[i].col;
        b.array[b_idx].col = a.array[i].row;
        b.array[b_idx].e = a.array[i].e;
    }
    return OK;
}
```

通常，当 e_num 远小于 row_num+col_num 且 e_num>col_num 时，转置操作选用时间复杂度为 **$$O(col{\_}num+e{\_}num)$$** 的快速转置算法，虽然需要另外增加两个辅助数组，但它的效率是最高的。
