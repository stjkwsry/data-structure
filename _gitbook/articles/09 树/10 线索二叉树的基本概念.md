# 线索二叉树的基本概念

二叉树的遍历运算是将二叉树中的结点按照一定的规律线性化的过程，当以二叉链表作为存储结构时，只能找到结点的左、右孩子信息，而不能直接得到结点的遍历序列中的前驱和后继信息。当需要得到某个结点的前驱或后继时，要将二叉树重新遍历一遍以获得结点的前驱和后继，但这种动态访问浪费时间，效率不高。

在具有 $$n$$ 个结点的二叉链表中，共有 $$2n$$ 个指针域，其中有 $$n+1$$ 个指针域为空。事实上，**可以利用这 $$n+1$$ 个空指针域把遍历过程中结点的前驱或后继信息保存下来**，以后就可以用这些指针域中的信息来查找结点的前驱或后继。

以上述讨论为基础，现在的二叉树结点中的指针域有可能指向该结点的左、右孩子，也有可能指向该结点的前驱或后继。为了区分指针域所指向的是孩子还是前驱或后继，为结点结构增设两个标志域，其一般数据结构定义如下：

```c
typedef struct Node {
    ElemType Data;
    // 左孩子标志、右孩子标志
    int LTag, RTag;
    struct Node *LChild, *RChild;
} ThreadBinaryTreeNode, *ThreadBinaryTreePoint;
```

对于该结构，做出以下规定：

- 若结点有左子树，令 LTag=0，表示其 LChild 域指向其左孩子；否则，令 LTag=1，表示 LChild 域指向该结点的遍历前驱结点。
- 若结点有右子树，令 RTag=0，表示其 RChild 域指向其右孩子；否则，令 RTag=1，表示 RChild 域指向该结点的遍历后继结点。

在这种存储结构中，指向前驱或后继结点的指针叫做**线索**，把这种存储结构组成的二叉链表叫做**线索二叉链表**。对二叉树以某种顺序进行遍历并加上线索的过程叫做对二叉树的**线索化**，线索化了的二叉树就称之为**线索二叉树**。