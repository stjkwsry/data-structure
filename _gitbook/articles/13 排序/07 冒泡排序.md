<img src="./images/冒泡排序.gif" style="zoom:67%;" />

# 算法实现

冒泡排序的一般算法实现如下：

```c
// 把排好的放在（归位在）前面
void BubbleSort(DataType a, int n) {
    // 只需 n-1 趟即可完成排序
	for(int i = 1; i <= n-1; i++) {
        // 判断本次遍历是否有交换元素，以便提前结束排序，节省时间
		int isSwap = 0;
        // 内循环遍历元素，从最后一个元素往前遍历
        // 结束条件需要加上 i，因为第 i 趟有 i 个元素已经排好序，不用再去管它
		for(int j = n; j >= 1 + i; j--) {
            // 若当前元素比上一个元素小，就交换位置，也就是把小的元素放在前面，即升序排序
            // 升序排序的判断条件：a[j].key < a[j - 1].key 或 a[j - 1].key > a[j].key
            // 降序排序的判断条件：a[j].key > a[j - 1].key 或 a[j - 1].key < a[j].key
			if(a[j].key < a[j - 1].key) {
				ElemType temp = a[j];
				a[j] = a[j - 1];
				a[j - 1] = temp;
				isSwap = 1;
			}
		}
		if (!isSwap) {
            break;
        }
	}
}

// 把排好的放在（归位在）后面
void BubbleSort(DataType a, int n) {
	for(int i = 1; i <= n - 1; i++) {
		int isSwap = 0;
		for(int j = 1; j <= n - i; j++) {
            // 升序排序的判断条件：a[j].key > a[j + 1].key 或 a[j + 1].key < a[j].key
            // 降序排序的判断条件：a[j].key < a[j + 1].key 或 a[j + 1].key > a[j].key
			if(a[j].key < a[j + 1].key) {
				ElemType temp = a[j];
				a[j] = a[j + 1];
				a[j + 1] = temp;
				isSwap = 1;
			}
		}
		if(!isSwap) {
            break;
        }
	}
}
```

冒泡排序的**已排序区归位**在前还是在后，**取决于内循环遍历的起点**：

- **归位在前** - 从最后一个元素开始往前遍历。
- **归位在后** - 从第一个元素开始往后遍历。

# 性能分析

> 考试默认使用归位在前的升序冒泡排序。

如果数据元素初始**已经排好序**，那么只需要进行 **1 轮排序**，**比较次数为 $$n-1$$**，**移动次数为 0**。

如果数据元素处于最坏情况的逆序时，则需要 **$$n-1$$ 轮排序**，**比较次数为 $$1+2+3+{\cdots}+n-1=n(n-1)/2$$**。

冒泡排序的**时间复杂度为 $$O(n^2)$$**，**空间复杂度为 $$O(1)$$**。

由于冒泡排序是根据输入序列的顺序的大小来决定排序后的位置，所以是一种**稳定的**排序方法。