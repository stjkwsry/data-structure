# 快速排序

<img src="./images/快速排序.gif" style="zoom:67%;" />

## 快速排序的基本思想

快速排序算法是由 C.A.R. Hoare 在 1962 年提出的一种基于**分治法**的排序算法。

通过一轮排序将序列分割成两部分，**其中一部分序列的关键字均比另一部分的关键字小（一般是左小右大）**。而后继续对两部分进行分割，最后达到整体有序。

在排序过程中，由于已经分开的两部分元素不再需要进行比较，故**减少了比较次数**，**降低了排序时间**。

具体步骤描述如下：

1. 在需要排列的序列 $$a$$ 中**任意选择一个中轴值（基准值）**。
2. **分** - 将 $$a$$ 分割成两个部分，其中左部分 $$b$$ 中的元素均**小于**中轴值，右部分 $$c$$ 中的元素均**大于或等于**中轴值。
3. **治** - 通过**递归**调用快速排序的过程，分别对这两个部分进行排序。
4. **合** - 将这两部分产生的结果合并，即可得到最后的排序序列。

中轴值的选择有多种方法，最简单的方法是使用第一个数据元素的关键字值。但是，如果数组是**完全正序**或者是**完全逆序**的，就会将所有数据元素分到中轴值的另一边。较好的方法是**随机选择**中轴值，这样可以**减少原始输入对排序造成的影响**，但随机选择的**开销较大**。

## 快速排序的算法实现

快速排序的一般算法实现如下：

```c
void QuickSort(DataType a, int low, int high) {
	int i = low, j = high;
	ElemType temp = a[low];
	while (i < j) {
		while (a[j].key >= temp.key && j > i) {
			j--;
		}
		if (j > i) {
			a[i] = a[j];
			i++;
		}
		while (a[i].key <= temp.key && i < j) {
			i++;
		}
		if (i < j) {
			a[j] = a[i];
			j--;
		}
	}
	a[i] = temp;
	if (low < i - 1) {
		QuickSort(a, low, i - 1);
	}
	if (j + 1 < high) {
		QuickSort(a, j + 1, high);
	}
}
```

## 快速排序的性能分析

当中轴值不能很好地分割数组，即中轴值将数组分割成**其中一个子数组中只有一个数据元素**，**另一个子数组中有 $$n-2$$ 个数据元素时**，下一次处理的子数组只比原数组小 1，这是快速排序**最坏情况**。如果这种情况发生在每一次划分过程中，那么快速排序算法的**时间复杂度就为 $$O(n^2)$$**。

如果每个中轴值都能将数组**分成相等的两部分**，则出现快速排序的**最好情况**。在这种情况下，还需要对每个**大小约为 $$n/2$$ 的两个子数组**进行排序。在一个大小为 $$n$$ 的序列中确定一个数据元素的位置所需要的时间为 **$$O(n)$$**。

若 $$T(n)$$ 为对 $$n$$ 个数据元素进行排序所需要的时间，则当每一个数据元素得到其正确位置，数组大致分成两个相等的部分时，可以得到快速排序的**最好情况下的时间复杂度 $$O(n{\log}_{2}n)$$**：

$$
T(n)\leq{cn}+2T(n/2)
$$

$$
T(n)\leq{cn}+2(cn/2+2T(n/4))=2cn+4T(n/4)
$$

$$
T(n)\leq2cn+4(cn/4+T(n/8))=3cn+iT(n/8)
$$

$$
{\cdots}
$$

$$
T(n)\leq{cn}\log_2{n}+nT(1)=O(n\log_2{n})
$$

其中 $$cn$$ 是一次划分所用的时间，$$c$$ 是一个常数。

在**最坏情况**下，每次划分都只得到一个子序列，**时间复杂度为 $$O(n^2)$$**：

$$
T(n)=cn+T(n-1)
$$

$$
T(n)=cn+c(n-1)+T(n-2)=2cn-c+T(n-2)
$$

$$
T(n)=2cn-c+c(n-2)+T(n-3)=3cn-3c+T(n-3)
$$

$$
{\cdots}
$$

$$
T(n)=(n-1)cn+\frac{cn(n-1)}{2}+T(1)=O(n^2)
$$

快速排序的时间复杂度在**平均情况**下介于最好与最坏情况之间。假设在每一次分隔时，中轴值处于最终排好序的位置的概率是一样的，中轴值将数组分成长度为 0 和 $$n-1$$，1 和 $$n-2$$……的概率都是 $$1/n$$。在这种假设下，快速排序算法的平均时间复杂度为：

$$
T(n)=cn+1/n(T(k)+T(n-k-1))\ \ \ \ \ T(0)=c,T(1)=c
$$

这是一个递归公式，$$T(k)$$ 和 $$T(n-k-1)$$ 是指处理长度为 $$k$$ 和 $$n-k-1$$ 数组时快速排序算法所花费的时间，根据公式可以推出快速排序的**平均时间复杂度为 $$O(n{\log}_{2}n)$$**。

快速排序是一个**不稳定的**排序方法。