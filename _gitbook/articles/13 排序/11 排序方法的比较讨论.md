# 内部排序方法的比较讨论

各种排序方法各有优缺点，使用的场合也各有不同，在选择排序方法时应该考虑的因素有：

1. 待排序数据元素的数量 $$n$$ 的大小。
2. 数据元素本身除关键字外的其他信息量的大小。
3. 关键字的情况。
4. 对排序稳定性的要求。
5. 语言工具的条件，辅助空间的大小等。

综合考虑以上因素，可以得出以下几个结论：

1. 若数据元素**在初始状态就基本有序**，可以采用**直接插入排序**或**冒泡排序**。
2. 若排序**数据元素的数量 $$n$$ 较小**，可以采用**直接插入排序**或**简单选择排序**。
   - 由于直接插入排序所需的数据元素移动操作比简单选择排序多，**在数据元素本身的信息量较大时，使用简单选择排序更好**。
3. 若排序**数据元素的数量 $$n$$ 较大**，可以采用时间复杂度为 $$O(n{\log}_{2}n)$$ 的**快速排序**、**堆排序**和**归并排序**。
   - 快速排序的**平均性能最好**，在待排序序列已经按关键字随机分布时，快速排序最合适。
   - 快速排序在最坏情况下的时间复杂度是 $$O(n^2)$$，而堆排序在最坏情况下的时间复杂度不会发生变化，并且所需的**辅助空间**少于快速排序。
   - 快速排序和堆排序都是不稳定的排序方法，若**需要保证稳定性**，则可以采用**归并排序**。
4. 基数排序可以在 $$O(d{\times}n)$$ 时间内完成对 $$n$$ 个数据元素的排序，当 $$n$$ 很大、$$d$$ 较小时，可以采用基数排序，但基数排序只适合于字符串或整数这种**具有明显结构特征的关键字**。
5. 当待排序的数据元素非常多时，为了避免花费大量时间进行数据元素的移动，可以采用**链式存储结构**存储数据元素。
   - **直接插入排序**和**归并排序**都可以非常容易地在链表上实现，但**快速排序**和**堆排序**却很难在链表上实现。

在上文的各种内部排序方法中，就所需的**计算时间**来看，**快速排序**、**归并排序**、**堆排序**是非常具有优势的，但归并排序需要大小为 $$n$$ 的辅助空间，快速排序需要一个额外的栈。除了**快速排序**、**堆排序**、**选择排序**和**希尔排序**是**不稳定的**排序方法外，其他排序方法都是稳定的。

**评价一个排序算法性能好坏的主要标准是它所需的计算时间和存储空间**，影响计算时间的两个重要因素是**比较关键字的次数**和**数据元素的移动次数**。

各种排序方法的性能比较如下：

| 排序方法     | 最好时间复杂度      | 最坏时间复杂度      | 平均时间复杂度          | 辅助空间           | 稳定性 |
| ------------ | ------------------- | ------------------- | ----------------------- | ------------------ | ------ |
| 直接插入排序 | $$O(n)$$            | $$O(n^2)$$          | $$O(n^2)$$              | $$O(1)$$           | 稳定   |
| 希尔排序     | $$O(n)$$            | $$O(n^2)$$          | $${\approx}O(n^{1.3})$$ | $$O(1)$$           | 不稳定 |
| 冒泡排序     | $$O(n)$$            | $$O(n^2)$$          | $$O(n^2)$$              | $$O(1)$$           | 稳定   |
| 快速排序     | $$O(n{\log}_{2}n)$$ | $$O(n^2)$$          | $$O(n{\log}_{2}n)$$     | $$O({\log}_{2}n)$$ | 不稳定 |
| 简单选择排序 | $$O(n^2)$$          | $$O(n^2)$$          | $$O(n^2)$$              | $$O(1)$$           | 不稳定 |
| 堆排序       | $$O(n{\log}_{2}n)$$ | $$O(n{\log}_{2}n)$$ | $$O(n{\log}_{2}n)$$     | $$O(1)$$           | 不稳定 |
| 归并排序     | $$O(n{\log}_{2}n)$$ | $$O(n{\log}_{2}n)$$ | $$O(n{\log}_{2}n)$$     | $$O(n)$$           | 稳定   |
| 基数排序     | $$O(d(n+rd))$$      | $$O(d(n+rd))$$      | $$O(d(n+rd))$$          | $$O(rd)$$          | 稳定   |

没有哪一种排序方法是绝对最优的，在实际应用时需要根据不同情况适当选用，甚至可以将多种方法结合使用。

