<img src="./images/归并排序.gif" style="zoom:67%;" />

# 基本思想

**归并排序（Merge Sort）**的基本思想是：

1. 将 $$n$$ 个长度的序列分成 $$n$$ 个长度为 1 的子序列。
2. 将这些子序列两两归并，得到 $$[n/2]$$ 个长度为 2 的**有序子序列**（若 $$n$$ 为奇数，会剩余一个子序列没有合并）。
3. 继续把这 $$[n/2]$$ 个长度为 2 的子序列两两归并。
4. 如此反复，直到最后得到一个长度为 $$n$$ 的有序子序列。

这种排序方法也被称为**二路归并排序**。

例如，有关键字序列 (62,38,53,26,18,33,56,45)，其二路归并排序过程如下：

| 轮次     | 序列                              |
| -------- | --------------------------------- |
| 一轮归并 | ((38,62),(26,53),(18,33),(45,56)) |
| 二轮归并 | ((26,38,53,62),(18,33,45,56))     |
| 三轮归并 | (18,26,33,38,45,53,56,62)         |

# 算法实现

归并排序的一般算法实现如下：

```c
// 数组需要从 0 开始存储元素
// l 为最小下标，r 为最大下标
// nums 为需要排序的序列，排序后的结果同样返回 nums，temp 只是一个临时的存储空间
void MergeSort(DataType nums, int l, int r, DataType temp) {
    // 下标有效性校验
	if (l + 1 >= r) {
		return;
	}
    
	// 子序列拆分
	int m = l + (r - l) / 2;
	MergeSort(nums, l, m, temp);
	MergeSort(nums, m, r, temp);
    
	// 关键字排序
	int p = l, q = m, i = l;
    // while (l < m || m < r)
	while (p < m || q < r) {
        // if (m >= r || (l < m && nums[l].key <= nums[m].key))
		if (q >= r || (p < m && nums[p].key <= nums[q].key)) {
            // temp[i] = nums[l]
			temp[i++] = nums[p++];
		} else {
            // temp[i] = nums[m]
			temp[i++] = nums[q++];
		}
	}
    
    // 将临时数组的元素赋给目标数组
	for (i = l; i < r; ++i) {
		nums[i] = temp[i];
	}
}
```

# 性能分析

二路归并排序的过程需要进行 **$$[{\log}_{2}n]$$** 轮，每一轮归并排序的操作就是将两个有序序列进行归并。

而每一对有序子文件归并时，数据元素的比较次数均小于或等于数据元素的移动次数，数据元素的移动次数均等与序列中数据元素的个数 n，即每一轮归并的时间复杂度为 **$$O(n)$$**。所以可得二路归并排序的时间复杂度为 **$$O(n{\log}_{2}n)$$**。

二路归并排序是**稳定的**，会保证数据元素的相对次序不会改变。