# 基数排序

<img src="./images/基数排序.gif" style="zoom: 67%;" />

## 基数排序的基本思想

**基数排序（Radix Sort）**是和上文各类排序方法完全不同的一种排序方法。

在之前，主要是通过数据元素之间的**比较**和**移动**两种操作来实现排序，基数排序则是根据关键字**每个位**上的**有效值**，并借助**分配**和**收集**两种操作来进行排序。

### 单关键字和多关键字

序列中任意一个数据元素的关键字均由 $$d$$ 个分量（变量） $$k_i^0$$，$$k_i^1$$，$${\cdots}$$，$$k_i^{d-1}$$ 构成。若这 $$d$$ 个分量中，**每个分量都是一个独立的关键字（构成一组关键字）**，则称这个序列是多关键字的，否则称这个序列是单关键字的。

> 例如：一张扑克牌由花色和点数两个分量构成一组关键字，称扑克牌是多关键字序列；十进制整数数组的关键字是十进制整数，称之为单关键字序列。

在多关键字排序中，**每个关键字都能决定数据元素的大小**。

> 例如：扑克牌的黑桃比方块大，若花色相同，则再比较点数大小。

多关键字中，**每个关键字的取值范围一般都不同**。

> 例如：扑克牌的花色的取值范围只有 4 种，而点数有 13 种。

对于单关键字序列排序可以使用多关键字排序的方法，只是**单关键字的每个位上的取值范围一般都相同**。

> 例如：十进制整数每一位上的取值范围都是 0~9。

### 基数

设单关键字的每个分量的取值范围均为 $$C_0{\leq}K_j{\leq}C_{rd-1}(0{\leq}j{\leq}d)$$，则**把每个分量可能取到的值的个数** $$rd$$ 称为**基数**。

基数的选择和关键字的分解与关键字的类型有关，例如：

1. **十进制整数** - 按照各个位进行分解，$$rd=10$$，$$C_0=0$$、$$C_9=9$$，$$d$$ 为最大的那一位。
2. **小写的英文字符串** - $$rd=26$$，$$C_0$$='a'、$$C_{25}$$='z'，$$d$$ 为字符串的最大长度。
3. **扑克牌** - 花色的基数 $$rd_1=4$$，点数的基数 $$rd_2=13$$，$$d$$ 为同时使用扑克牌的副数。

基数排序是一种**将单关键字按照基数分成多关键字进行排序**的方法。

### 排序过程

以扑克牌的桥牌游戏为例。

每张扑克牌都由两个关键字构成一组关键字，即花色和点数，其有序关系为：

- **花色** - ♣ < ♦ < ♥ < ♠
- **点数** - 2 < 3 < 4 < 5 < 6 < 7 < 8 < 9 < 10 < J < Q < K < A

如果把所有扑克牌按照升序排序，会得到以下序列：

♣2，……，♣A，♦2，……，♦A，♥2，……，♥A，♠2，……，♠A

这就是多关键字排序，排序后形成的有序序列叫做**词典有序序列**。

> 对于扑克牌的两个关键字的排序，可以先按花色、再按点数排序，也可以先按点数、再按花色排序。

在一般情况下，假定有一个包含 $$n$$ 个对象的序列 $$(V_0,V_1,{\cdots},V_{n-1})$$，且每个对象 $$V_i$$ 中含有 $$d$$ 个关键字 $$(k_i^0,k_i^1,{\cdots},k_i^{d-1})$$。

如果对于序列中任意两个对象 $$V_i$$ 和 $$V_j(0{\leq}i<j{\leq}n-1)$$ 都满足 $$(k_i^0,k_i^1,{\cdots},k_i^{d-1})<(k_j^0,k_j^1,{\cdots},k_j^{d-1})$$，则称序列对于关键字 $$(k^0,k^1,{\cdots},k^{d-1})$$ 有序，其中：$$k^0$$ 称为最高位关键字，$$k^1$$ 称为次高位关键字，$$k^{d-1}$$ 称为最低为关键字。

基数排序的方法有两种：

1. **最高位优先法（Most Significant Digit First），简称 MSD 法** - 先按照 $$k^0$$ 排序，并将 $$k^0$$ 相同的数据元素分成一组，再把 $$k^0$$ 各组中 $$k^1$$ 相同的数据元素分成一组，如此反复，直到按照 $$k^{d-1}$$ 对各子组进行排序后，将各组连接起来，便得到一个有序序列。
2. **最低位优先法（Least Significant Digit First），简称 LSD 法** - 与 MSD 法相反，从 $$k^{d-1}$$ 到 $$k^0$$ 进行分组排序。

例如有序列 ("ead","bed","dad","add","bee","abc","dbe","dae","cda","eba","cdd")，对其使用 MSD 法进行升序排序的过程如下：

首先根据第一个字母排序，并将第一个字母相同的数据元素放到一组：

| 第一个字母 | 数据元素          |
| ---------- | ----------------- |
| 'a'        | "add","abc"       |
| 'b'        | "bed","bee"       |
| 'c'        | "cda","ccd"       |
| 'd'        | "dad","dbe","dae" |
| 'e'        | "ead","eba"       |

然后根据第二个字母排序，并将第二个字母相同的数据元素放到一组：

| 第一个字母 | 第二个字母 | 数据元素    |
| ---------- | ---------- | ----------- |
| 'a'        | 'b'        | "abc"       |
| ~          | 'd'        | "add"       |
| 'b'        | 'e'        | "bed","bee" |
| 'c'        | 'c'        | "ccd"       |
| ~          | 'd'        | "cda"       |
| 'd'        | 'a'        | "dad","dae" |
| ~          | 'b'        | "dbe"       |
| 'e'        | 'a'        | "ead"       |
| ~          | 'b'        | "eba"       |

最后根据第三个字母排序，并将第三个字母相同的数据元素放到一组：

| 第一个字母 | 第二个字母 | 第三个字母 | 数据元素 |
| ---------- | ---------- | ---------- | -------- |
| 'a'        | 'b'        | 'c'        | "abc"    |
| ~          | 'd'        | 'd'        | "add"    |
| 'b'        | 'e'        | 'd'        | "bed"    |
| ~          | ~          | 'e'        | "bee"    |
| 'c'        | 'c'        | 'd'        | "ccd"    |
| ~          | 'd'        | 'a'        | "cda"    |
| 'd'        | 'a'        | 'd'        | "dad"    |
| ~          | ~          | 'e'        | "dae"    |
| ~          | 'b'        | 'e'        | "dbe"    |
| 'e'        | 'a'        | 'd'        | "ead"    |
| ~          | 'b'        | 'a'        | "eba"    |

最后将各组连接起来即可得到升序排序的有序序列。

> **<font color="red">LSD 法的排序结果和 MSD 法一样，只是排序过程中数据元素交换的次序有些区别。</font>**

## 基数排序的算法实现

以十进制整数序列进行顺序分配的基数排序的一般算法实现如下：

```c
#include <stdio.h>
#include <stdlib.h>

int main() {
    // 待排序序列
	int data[10] = { 73, 212, 93, 43, 55, 114, 28, 65, 319, 81 };
    // 由于序列是十进制整数，可以得到：rd=10，C_0=0、C_9=9
    // temp[rd][data.length] 用来存储排序后的分组
	int temp[10][10] = { 0 };
    // order[rd] 用来记录对应位数上存储的数据元素个数
	int order[10] = { 0 };
	
    // 打印排序前的序列
	for (int i = 0; i < 10; i++) printf("%d ", data[i]);
	puts("");
	
    // 此处以 LSD 法进行基数排序
    int n = 1;
    // 如果序列中的最大数据元素位数大于百位，就要继续增加 n 的变化范围
	while (n <= 100){
        // 遍历序列
		for (int i = 0; i < 10; i++){
            // 获取数据元素中未处理的位上的值
			int lsd = ((data[i] / n) % 10);
            // 把数据元素放到对应的分组中 => lsd | data[i_0] data[i_1] ...
			temp[lsd][order[lsd]] = data[i];
            // 更新 lsd 位上存储的数据元素个数
			order[lsd]++;
		}
        // 将分组连接回序列
		for (int i = 0, k = 0; i < 10; i++){
			if (order[i] != 0) for (int j = 0; j < order[i]; j++){
				data[k] = temp[i][j];
				k++;
			}
            // 初始化对应位上存储的数据元素个数，确保下一轮的分配和收集能正确执行
			order[i] = 0;
		}
        // 更新下一轮的位数
		n *= 10;
	}
	
    // 打印排序后的序列
	for (int i = 0; i < 10; i++) printf("%d ", data[i]);
	
	return 0;
}
```

基数（rd）决定了队列（`temp[rd][data.length]`、`order[rd]`）的数目，数据元素的位数（n）决定了循环次数（while）。

**LSD** 的基数排序适用于**位数小**的数列，如果**位数多**的话，使用 **MSD** 的效率会比较好。

> **<font color="red">对于数据元素长度不同的序列，可以通过在数据元素面前加上 $C_0$ 来进行处理，例如十进制整数序列可以在数据元素前加 0。</font >**

## 基数排序的性能分析

对于 $$n$$ 个记录，执行一次分配和收集的时间为 $$O(n+rd)$$，如果关键字有 $$d$$ 位，则要执行 $$d$$ 遍，所以总的运算时间为 **$$O(d(n+rd))$$**。

对于不同的基数 $$rd$$ 所用的时间显然是不同的，当 $$rd$$ 或 $$d$$ 较小时，上文**顺序分配**的基数排序算法实现较为节省时间。

基数排序同样适用于**链式分配**的数据元素的排序，其要求的附加存储量是 $$rd$$ 个队列的头、尾指针，附加存储量为 $$2rd$$ 个存储单元。由于待排序数据元素是以链表的形式存储，相对于顺序分配而言，只增加了 $$n$$ 个指针域的空间，共计增加 **$$n+2rd$$** 个附加链接指针。

**基数排序是稳定的排序方法**。

