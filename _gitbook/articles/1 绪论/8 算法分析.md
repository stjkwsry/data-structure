# 算法分析

一个算法设计好了之后会评价算法的效率和优劣，估算算法效率的方法就称作**算法分析（Algorithm Analysis）**，通常考虑对算法所消耗的资源进行估算，采用的方法有**事后统计法**和**事前分析估算法**。

## 事后统计法

利用计算机内部的计时功能，得到一组统计数据以分辨算法执行效率的优劣，但事后统计必须先运行依据算法编制的程序，所有得到的时间统计都依赖于计算机的硬件、软件等环境因素（例如与计算机的指令集或编译系统的质量有关），有时容易掩盖算法本身的优劣。

因此，往往采用事前分析估算的方法分析算法。

## 事前分析估算法

一个用高级程序语言编写的程序在计算机上运行时所消耗的时间取决于以下因素：

- 依据算法选用何种策略。
- 问题的规模。例如求 100 以内的素数还是求 1000 以内的素数，**规模越大，执行效率越低**。
- 书写程序的语言。对于同一个算法，**实现语言的级别越高，执行效率越低**。
- 编译程序所产生的机器代码的质量。
- 机器执行指令的速度。

后三种因素都与具体的机器有关，抛开这些因素，仅考虑算法本身的效率高低，可以认为**一个特定算法的运行工作量的大小只依赖于问题的规模**（通常用整数 $$n$$ 表示），或者说**效率是问题规模的函数**。

一个算法是由**控制结构**（顺序、分支和循环）和**原操作**（指固有数据类型的操作）构成的，**算法时间**取决于两者的综合效果。

为了便于比较同一问题下的不同算法，通常的做法是从算法中选取一种对于所研究的问题来说是基本运算的原操作，以该基本运算重复执行的次数作为算法的时间度量。

评价一个算法，通常用时间复杂度和空间复杂度进行衡量。

- **时间复杂度** - 指执行算法所需要的计算工作量。
- **空间复杂度** - 指执行算法所需要的内存空间。

## 时间复杂度

例如矩阵求和算法：

```c
int sum = 0;
for (int i = 0; i < n; i++) {
    for (int j = 0; j < n; j++){
        sum += arr[i][j];
    }
}
```

该程序中，外层循环的频度是 $$n+1$$，但它的循环体却只能执行 $$n$$ 次，$$1$$ 是指结束循环的判断；内层循环作为外层循环的循环体，应该执行 $$n$$ 次，但内层循环本身也要执行 $$n+1$$ 次，所以内层循环的频度是 $$n(n+1)$$；同理，求和赋值语句的频度为两个循环体执行次数的积，即 $$n^2$$。

因此，这一段算法的时间消耗（即所有语句的频度之和）为：


$$
n+1+n(n+1)+n^{2}=2n^{2}+2n+1
$$


它是矩阵阶数 $$n$$ 的函数。

一般用问题规模 $$n$$ 的函数 $$T(n)$$ 表示算法的**时间复杂度（Time Complexity）**，当规模 $$n$$ 趋向无限大时，把 $$T(n)$$ 的数量级（阶）称为**渐进时间复杂度**，通常用 $$O$$、$${\Omega}$$、$${\theta}$$、$$o$$ 表示。

- **$$O$$** - 设 $$f(n)$$ 和 $$g(n)$$ 是从自然数集到非负数集的两个函数，如果存在一个自然数 $$n_0$$ 和一个常数 $$c>0$$，使得 $${\vee}n{\geqslant}n_0$$、$$f(n){\leqslant}cg(n)$$，则记为 $$f(n)=O(g(n))$$，且称 $$g(n)$$ 是 $$f(n)$$ 的上界。
- **$${\Omega}$$** - 设 $$f(n)$$ 和 $$g(n)$$ 是从自然数集到非负数集的两个函数，如果存在一个自然数 $$n_0$$ 和一个常数 $$c>0$$，使得 $${\forall}n{\geqslant}n_0$$、$$f(n){\geqslant}cg(n)$$，则记为 $$f(n)={\Omega}(g(n))$$，且称 $$g(n)$$ 是 $$f(n)$$ 的下界。
- **$${\theta}$$** - 设 $$f(n)$$ 和 $$g(n)$$ 是从自然数集到非负数集的两个函数，如果存在一个自然数 $$n_0$$ 和两个正常数 $$c_1>0$$、$$c_2>0$$，使得 $${\forall}n{\geqslant}n_0$$、$$c_1g(n){\leqslant}f(n){\leqslant}c_2g(n)$$，则记为 $$f(n)={\theta}(g(n))$$，且称 $$g(n)$$ 和 $$f(n)$$ 同阶。
- **$$o$$** - 设 $$f(n)$$ 和 $$g(n)$$ 是从自然数集到非负数集的两个函数，如果存在一个自然数 $$n_0$$ 和一个常数 $$c>0$$，使得 $${\forall}n{\geqslant}n_0$$、$$f(n)<cg(n)$$，则记为 $$f(n)=o(g(n))$$，且称 $$g(n)$$ 是 $$f(n)$$ 的严格上界。

设 $$T(n)$$ 为算法的时间复杂度，问题规模为 $$n$$，$$f(n)$$ 为 $$n$$ 的某个函数，若 $$T(n)=O(f(n))$$，则称 $$f(n)$$ 为算法的时间复杂度上界。

在上例中可得：


$$
T(n)=2n^{2}+2n+1
$$


由于当 $$n$$ 趋向于无穷大时，有下式成立：


$$
{\lim_{n\to\infty}}{\frac{T(n)}{n^{2}}}={\lim_{n\to\infty}}{\frac{2n^{2}+2n+1}{n^{2}}}=2
$$


这表明，当规模 $$n$$ 趋向无穷大时，$$T(n)$$ 和 $$n^2$$ 是同阶的（数量级相同），即 **$$T(n)=O(n^2)$$**（取最大的项），这就是上例的渐进时间复杂度（简称为时间复杂度）。

- 在一个没有循环的算法中，基本运算次数与问题规模 $$n$$ 无关，通常记为 **$$O(1)$$**，也称为**常阶数**。
- 在一个只有一重循环的算法中，基本运算次数与问题规模 $$n$$ 的增长呈线性增长关系，记作 **$$O(n)$$**，也称为**线性阶**。
- 其余的还有**平方阶 $$O(n^2)$$**、**立方阶 $$O(n^3)$$**、**对数阶 $$O(log^2n)$$** 和**指数阶 $$O(2^n)$$** 等。

各种不同数量级对应的值存在如下关系：


$$
O(1)<O(\log_{2}n)<O(n)<O(n\log_{2}n)<O(n^{2})<O(n^{3})<O(2^{n})<O(n!)
$$


通常应尽可能地选用**多项式阶 $$O(n^k)$$** 的算法，而不是选用**指数阶 $$O(2^n)$$** 及以上的算法（此时称算法在计算上是不可行的）。

当评价一个算法的时间性能时，主要观察其时间复杂度的**数量级**，即渐进时间复杂度。在分析一个算法的时间复杂度前，需要先了解计算**增长率**的加法规则和乘法规则。

设 $$T_1(n)=O(f(n))$$、$$T_2(n)=O(g(n))$$，则有以下两条规则：

1. **加法规则** - 设 $$T_1(n)$$ 和 $$T_2(n)$$ 是程序片段 $$p_1$$ 和 $$p_2$$ 的运行时间。执行 $$p_1$$ 之后紧接着执行 $$p_2$$ 的运行时间得到 $$T_1(n)+T_2(n)$$，即 $$O(max{f(n),g(n)})$$。
2. **乘法规则** - $$T_1~(n){\times}T_2(n)=O(f(n){\times}g(n))$$。

算法的时间复杂度依赖于**输入的初始数据（数据的初态和问题的规模）**。

一般地，以最坏情况下的时间复杂度作为算法的时间复杂度，也就是说**时间复杂度是估算算法执行时间的一个上界**。

简单来说，分析一段程序的时间复杂度只需要：

1. 找出语句**频度最高**的那条语句作为**基本语句**。
2. 计算基本语句的频度得到关于规模 $$n$$ 的函数 $$f(n)$$。
3. 忽略所有低次幂项和最高次幂系数。
4. 取其数量级，并用符号 $$O$$ 表示，如 $$O(n)$$。

例如：

```c
int sum = 0;
for (int i = 0; i < n; i++) {
	for (int j = 0; j < n; j++) {
        // 基本语句
		sum += i + j;
	}
}
```

只需要计算**基本语句**的频度，就能求出这段程序的时间复杂度为 **$$O(n^2)$$**。

## 空间复杂度

对于算法空间资源占用的讨论可以类似于时间复杂度，估算渐进空间复杂度简称为**空间复杂度（Space Complexity）**，表示为：


$$
S(n)=O(f(n))
$$


一个算法所占用的存储空间包括：

- 算法程序所占的空间。
- 输入的初始数据所占的存储空间。
- 算法执行过程中需要的额外空间。

其中，额外空间包括：

- 算法程序执行过程中的工作单元。
- 某种数据结构所需要的附加存储空间（例如在链式结构中，除了要存储数据本身外，还需要存储链接信息）。

如果额外空间量相对于问题规模来说是常数，则称此算法为**原地工作的**。

在许多实际问题中，为了减少算法所占的存储空间，通常采用压缩存储技术，以便减少不必要的额外空间。
