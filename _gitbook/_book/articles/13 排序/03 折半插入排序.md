# 算法实现

折半查找插入排序是**直接插入排序的优化版**。

在直接插入排序中，待插入元素与有序列的比较是线性的，可以**更改为折半查找比较元素**来提高效率。

折半插入排序的一般算法实现如下：

```c
void BinarySort(DataType a, int n) {
    for (int i = 2; i <= n; i++) {
        a[0] = a[i];
        // low = 有序列的最左，high = 有序列的最右
        int low = 1, high = i - 1;
        // 使用二分查找法寻找插入位置（high + 1）
        while (low <= high) {
            int mid = (low + high) / 2;
            if (a[0].key < a[mid].key) {
                high = mid - 1;
            } else {
                low = mid + 1;
            }
        }
        // 将插入元素之前、插入位置之后的元素往后挪
        for (int j = i - 1; j >= high + 1; j--) {
            a[j + 1] = a[j];
        }
        // 插入元素
        a[high + 1] = a[0];
    }
}
```

# 性能分析

从时间上比较，折半插入排序仅仅**减少了关键字的比较次数**，却没有减少数据元素的移动次数，所以**时间复杂度仍然为 $$O(n^2)$$**，也是一种**稳定的**排序方法。