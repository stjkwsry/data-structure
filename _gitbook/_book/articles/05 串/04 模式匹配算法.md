**子串的定位操作**，即**查找子串在主串中首次出现的位置**，是串非常重要的操作之一，该操作又称为**串的模式匹配（Pattern Matching）**。在模式匹配中，**主串**和**子串**也分别称作**目标串**和**模式串**。

串的模式匹配算法的基本思想是：**在主串 S 中，从第 position 个字符开始，查找是否存在子串 T。如果在 S 中找到了一个与 T 相同（长度相等，各个字符也相等）的子串，则匹配成功，返回 T 在 S 中的序号；否则匹配不成功，返回 0。**

# BF 算法

**Brute-Force 算法**（简称为 **BF 算法**，俗称简单匹配法、暴力破解法或穷举法）是常用的串的模式匹配算法，匹配过程比较容易理解。

设主串 $$S=s_{1}s_{2}...s_{n}$$，其长度为 $$n$$；设模式串 $$T=t_{1}t_{2}...t_{m}$$，其长度为 $$m$$。

从主串 $$S $$的第一个字符 $$s_1$$ 开始和模式串 $$T$$ 的第一个字符 $$t_1$$ 比较，若相等，则继续比较后续字符 $$s_2$$ 与 $$t_2$$；若不相等，则从主串 $$S$$ 的下一个字符 $$s_2$$ 开始重新与 $$t_1$$ 比较。如此反复比较。如果在主串 $$S$$ 中找到一个与 $$T$$ 相同的子串，则匹配成功，返回模式串 $$T$$ 在主串 $$S$$ 中的序号；如果比较完主串 $$S$$ 中的所有字符序列，没找到一个和模式串 $$T$$ 相等的子串，则匹配失败，返回 0。

BF 算法的一般实现如下：

```c
int BF(SqString S, SqString T) {
    // 前面规定了串的字符索引从 1 开始
	int i = 1, j = 1;
    while (i <= S[0] && j <= T[0]) {
        if (S[i] == T[j]) {
            i++, j++;
        } else {
            // 将 i 回溯到主串中第一个比较的字符的后一个字符
            // 例如在第一轮比较中，i=2，j=2，i-j=0,i=0+2=2，2 就是主串中第二个开始比较的字符的位置
            i = i - j + 2;
            j = 1;
        }
    }
    if (j > T[0]) {
        // 返回模式串在目标串中的起始位置（从 1 开始计算位置）
        return i - T[0];
    }
    return 0;
}
```

在匹配成功的情况下，有两种极端的情况。

## 最好情况

在最好情况下，每趟不成功的匹配都发生在第一对字符比较。设匹配成功发生在主串的 $$s_i$$ 处，则字符比较次数在前面 $$i-1$$ 趟匹配中，共比较了 $$i-1$$ 次，第 $$i$$ 趟成功的匹配共比较了 $$m$$ 次，所以总共比较了 $$i-1+m$$ 次，所有匹配成功的可能有 $$n-m+1$$ 种。设从 $$s_i$$ 开始与模式串匹配成功的概率为 $$pi$$，在等概率情况下 $$pi=1/(n-m+1)$$。因此，最好情况下平均比较的次数是：


$$
{\sum_{i=1}^{n-m+1}{pi}}\times{({i}\times{m})}={\sum_{i=1}^{n-m+1}\frac{1}{n-m+1}}\times{(i-1+m)}=\frac{n+m}{2}
$$

即在最好情况下，BF 算法的时间复杂度为 **$$O(n+m)$$**。

## 最坏情况

在最坏情况下，每趟不成功的匹配都发生在模式串的最后一个字符。设匹配成功发生在主串的 $$s_i$$ 处，则在前面 $$i-1$$ 趟匹配中，共比较了 $$(i-1){\times}m$$ 次，第 $$i$$ 趟成功的匹配共比较了 $$m$$ 次，所以总共比较了 $$i{\times}m$$ 次。因此，最坏情况下平均比较的次数是：


$$
{\sum_{i=1}^{n-m+1}{pi}}\times{({i}\times{m})}={\sum_{i=1}^{n-m+1}\frac{1}{n-m+1}}\times{({i}\times{m})}=\frac{m\times(n-m+2)}{2}
$$


即在最坏情况下，BF 算法的时间复杂度为 **$$O(n{\times}m)$$**。

BF 算法虽然简单且易于理解，**但每趟匹配不成功时存在大量回溯，没有利用已经部分匹配的结果**。如果能利用这部分匹配的结果，将模式向右滑动尽可能远的距离后继续比较，就能提高算法的效率，这种改进的模式匹配算法称为 KMP 算法。

# KMP 算法

**KMP 算法**是由 Knuth、Morris 和 Pratt 同时发现的，所以取名为 KMP 算法。

KMP 算法的设计思想是：利用已经**部分匹配的结果**（需要配合 **next 数组**一起使用）加快模式串的滑动速度，且主串的指针**不必回溯**，将时间复杂度提速到 **$$O(n+m)$$**。

首先来构造 next 数组。next 是 int 类型的数组，规定其元素值：

- **计算方式** - 第 $$j$$ 位字符的**前缀串**（不包括第 $$j$$ 位字符）能够组成的**最长的**首尾重合的子串的**重合字符数量+1**。
  - 设有串 "abacdef"，其中字符 c 的前缀串为 "aba"，不难看出，首尾各有一个子串 "a"，则称该子串为首尾重合的子串，重合字符数量为 1。而字符 d 的前缀串为 "abac"，第一位首尾就不相等了，所以 d 的前缀串中不包含首尾重合的子串。

- **应用意义** - **模式串的字符指针需要回退到的位置**。

由于串的 0 下标被用来存储串的长度，从 1 才开始存储字符序列，所以 **next 的 0 下标的值默认设置为 0**，从 1 开始存储模式串的字符指针需要回退的位置。

设有模式串 T="abaabcac"，j 为 T 的字符指针：

| j    | 1    | 2    | 3    | 4    | 5    | 6    | 7    | 8    |
| ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |
| T    | a    | b    | a    | a    | b    | c    | a    | c    |

- **默认规定所有的 next[1] 的值为 0。**
- 当 j=2 时，前缀串为 "a"，没有首尾重合的子串（**子串的长度至少为 2**），所以 next[2] 的值为 1（0+1）。
- 当 j=3 时，前缀串为 "ab"，没有首尾重合的子串，所以 next[3] 的值为 1（0+1）。
- 当 j=4 时，前缀串为 "aba"，首尾有子串 "a" 重合，重合字符数量为 1，所以 next[4] 的值为 2（1+1）。
- 当 j=5 时，前缀串为 "abaa"，首尾有子串 "a" 重合，重合字符数量为 1，所以 next[5] 的值为 2（1+1）。
- 当 j=6 时，前缀串为 "abaab"，首尾有子串 "ab" 重合，重合字符数量为 2，所以 next[6] 的值为 3（2+1）。
- 当 j=7 时，前缀串为 "abaabc"，没有首尾重合的子串，所以 next[7] 的值为 1（0+1）。
- 当 j=8 时，前缀串为 "abaabca"，首尾有子串 "a" 重合，重合字符数量为 1，所以 next[8] 的值为 2（1+1）。

故，next 数组的值为（0 下标的值默认为 0）：

| j    | 1    | 2    | 3    | 4    | 5    | 6    | 7    | 8    |
| ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |
| T    | a    | b    | a    | a    | b    | c    | a    | c    |
| next | 0    | 1    | 1    | 2    | 2    | 3    | 1    | 2    |

用代码来构造 next 数组的一般实现如下：

```c
void GetNext(SqString T, int next[]) {
    // 根据约定，设置 0 和 1 下标的值为 0
    next[0] = next[1] = 0;
    // i 用来控制模式串的字符指针，j 用来指向 i 字符的前缀字符以及记录重合的字符个数
    int i = 1, j = 0;
    // 遍历整个模式串，相当于给模式串也来一次模式匹配
    while (i < T[0]) {
        // T[i] 指向尾部字符，T[j] 指向首部字符，即判断首尾字符是否重合
        if (j == 0 || T[i] == T[j]) {
            // 如果重合了，就将 i 指向下一个字符，且值为重合的字符个数 j 加上 1
            next[++i] = ++j;
        } else {
            // 否则就将首部字符指针往前挪一位
            j = next[j];
        }
    }
}
```

KMP 算法的一般实现如下：

```c
int KMP(SqString S, SqString T) {
    int i = 1, j = 1;
    while (i <= S[0] && j <= T[0]) {
        if (j == 0 || S[i] == T[j]) {
            i++, j++;
        } else {
            // 主串的位置 i 不变，模式串的位置 j 后退
            j = next[j];
        }
    }
    if (j > T[0]) {
        return i - T[0];
    }
    return 0;
}
```
