排序是**把一组无序的数据元素按照关键字值递增或递减的顺序，重新排列成有序序列的过程**。

如果排序的依据是**主关键字**，那么排序的结果是**唯一的**。关键字就是数据元素中的某个数据项，如果某个数据项可以唯一地确定一个数据元素，就将其称为**主关键字**；否则就称为**次关键字**。

# 内部排序和外部排序

在排序过程中，以**待排序的所有数据元素是否全部被放置在内存中**来讨论，可以将排序方法分为**内部排序**和**外部排序**。

内部排序的整个排序过程完全在内存中进行，排序时**不涉及数据的内、外存交换**。

外部排序指的是**大文件的排序**，即待排序的文件无法一次装入内存，有部分记录存储在**外存储器**上，需要在内存和外部存储器之间进行多次数据交换，以达到排序整个文件的目的。外部排序最常用的算法是**多路归并排序**，即将原文件分解成多个能够一次性装入内存的部分，并把每一部分调入内存完成排序，然后对已排序的子文件进行归并排序。

> **<font color="red">后文不再介绍外部排序。</font>**

# 排序算法评价

排序算法的效率主要通过两点进行评价：

1. 在数据量规模一定的条件下，算法执行所消耗的平均时间、排序操作的时间**主要消耗在关键字之间的比较和数据元素的移动上**，因此可以认为，**高效率的排序算法应该是尽可能少的比较次数和尽可能少的移动次数**。
2. 执行算法所需要的**辅助存储空间**。

辅助存储空间是指在数据量规模一定的条件下，除了待排序数据元素占用的存储空间之外，执行算法所需要的其他存储空间。

> 理想的空间效率是算法执行期间所需要的辅助空间与待排序的数据量无关。

# 排序算法的稳定性

如果在排序的数据元素序列中有多个数据元素的**关键字值相同**，排序后这些数据元素的**相对次序保持不变**，则称这种算法是**稳定的**，反之则是**不稳定的**。

# 待排序数据元素序列的存储结构

待排序数据元素序列可以用**顺序存储结构**和**链式存储结构**表示。

对**顺序存储结构**进行排序时，是对序列中的数据元素本身进行物理重排，即通过关键字之间的比较判定，**将数据元素移动到合适的位置**。

对**链式存储结构**进行排序时，无须移动数据元素，**只需要修改指针**。

后续的待排序数据元素序列使用顺序存储结构表示（基排序除外），即用一维数组实现，一般数据结构定义如下：

```c
#define MAX_NUM 80

typedef int KeyType;

typedef struct {
    // 数据元素的关键字
    KeyType key;
    // 数据元素中的其他成分
    AnyType otherElem;
} DataType[MAX_NUM + 1];
```

测试用例如下：

```c
int main() {
    int n = 8;
	DataType a;
	a[1] = { 51, "51" };
	a[2] = { 33, "33" };
	a[3] = { 62, "62" };
	a[4] = { 96, "96" };
	a[5] = { 87, "87" };
	a[6] = { 17, "17" };
	a[7] = { 28, "28" };
	a[8] = { 51, "51\'" };
    // 排序算法
	HeapSort(a, n);
	for (int i = 1; i <= n; i++) {
		printf("key=%d,name=%s\n", a[i].key, a[i].name);
	}
	return 0;
}
```
