# 希尔排序

<img src="./images/希尔排序.gif" style="zoom: 80%;" />

## 希尔排序的基本思想

直接插入排序算法简单容易实现，但**在序列很长时**，对元素的比较和移动次数太多，就会影响排序的效率。但如果原始数据的**大部分元素已经有序**，那么插入排序的速度就很快，因为需要移动的元素很少。而希尔排序则是**对直接插入排序算法的改进**，又称为**缩小增量排序**。

希尔排序的基本思想是，将待排序的数据元素序列**分成几组**，每组的元素都比原来的序列少，从而减少参与直接插入排序的数据量，**在各组中分别进行直接插入排序**。经过几次分组排序后，数据元素的排序已经**基本有序**，这个时候再对所有的数据元素进行直接插入排序，即可完成序列的排序。

具体步骤描述如下：

1. 假设待排序的数据元素为 $$n$$ 个，先**取整数 $$d(d<n)$$**。例如，取 $$d=[n/2]$$。
2. 将所有距离为 $$d$$ 的数据元素构成一组，从而将整个待排序数据元素序列**分割成为 $$d$$ 个子序列**。
3. **对每个分组分别进行直接插入排序**，然后再缩小间隔 $$d$$。例如，取 $$d=d/2$$。
4. 重复上述的分组排序操作，直到最后取 **$$d=1$$**，即将所有数据元素放在一组里进行一次直接插入排序。

由于开始时**每组元素很少**，所以**排序很快**；之后每组含有的元素虽然越来越多，但是由于**这些元素也越来越有序**，所以**排序速度也很快**。

## 希尔排序的算法实现

希尔排序的一般算法实现如下：

```c
void ShellSort(DataType a, int n) {
    // 把待排序序列分组，初始为 n/2 组，之后每次循环更新为 d/2，直到 d=1
	for(int d = n/2; d >= 1; d /= 2) {
        // 每组的元素下标为 a[i] 和 a[d+i]
		for(int i = 1 + d, j; i <= n; i++) {
			a[0] = a[i];
            // j 从 i 开始
			for (j = i - d; j > 0 && a[0].key < a[j].key; j -= d) {
				a[j + d] = a[j];
			}
			a[j + d] = a[0];
		}
	}
}
```

但对于一般情况而言，**增量序列 $$D\{d\}$$ 必须是互质的（且最后一个值必须为 1）**，否则**非质数间隔可能不会为子序列排序，只起到了浪费时间的作用**，示意图如下：

![](https://img2020.cnblogs.com/blog/1255171/202003/1255171-20200303214131806-1135957907.png)

更为规范的希尔排序算法需要一个**辅助数组 dk**，即增量序列。著名的增量序列有：

- Hibbard 增量序列。
- Knuth 增量序列。
- Sedgewick 增量序列。

以 Hibbard 增量序列为例，其增量取法为：

$$
D_k=2^k-1:\{1,3,7,15,31,63,127,255,{\cdots}\}
$$

> 如何选择最佳增量序列，目前尚未解决。

下面是以 Hibbard 增量序列作为希尔排序的辅助数组的算法：

```c
void ShellSort(DataType a, int n) {
    // 构造 Hibbard 增量序列，一般取到第八位就够了
    int dk[8];
    for (int i = 1; i <= 8; i++) {
        dk[i - 1] = pow(2, i) - 1;
    }
    // 从尾部向前遍历增量序列
	for(int dk_idx = 7; dk_idx >= 0; dk_idx--) {
        int d = dk[dk_idx];
		for(int i = 1 + d, j; i <= n; i++) {
			a[0] = a[i];
			for (j = i - d; j > 0 && a[0].key < a[j].key; j -= d) {
				a[j + d] = a[j];
			}
			a[j + d] = a[0];
		}
	}
}
```

## 希尔排序的性能分析

在希尔排序中，由于开始将 $$n$$ 个待排序的数据元素分成了 $$d$$ 组，所以每组中的数据元素数量将会减少。在**数据量较少**时，利用直接插入排序的**效率较高**；随着反复分组排序，$$d$$ 值逐渐变小，每个分组中的待排序**数据元素数量增多**，但此时数据元素的**排列顺序更加接近有序**，所以利用直接插入排序**不会降低排序的时间效率**。

希尔排序的算法效率与**增量序列的取值**有关：

1. **Hibbard 增量序列** - 最坏情况为 **$$O(n^{3/2})$$**，猜想的平均情况为 **$$O(n^{5/4})$$**。
2. **Sedgewick 增量序列** - 最坏情况为 **$$O(^{4/3})$$**，猜想的平均情况为 **$$O(n^{7/6})$$**。

希尔排序的时间复杂度是 $$n$$ 和 $$d$$ 的函数，为 **$$O(n^{1.25}){\sim}O(1.6n^{1.25})$$（经验公式）**；空间复杂度为 **$$O(1)$$**。

希尔排序**适用于待排序序列的数据元素数量较大的情况**，一般要比直接插入排序方法快。

由于排序时分组的原因导致序列输入顺序与原始顺序不同，关键字相同的数据元素在排序后的相对次序可能会发生变化，因此希尔排序是一种**不稳定的**排序方法。

> <font color="red">希尔排序不适用于链式存储结构。</font>